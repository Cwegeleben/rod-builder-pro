// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

// Note that some adapters may set a maximum length for the String type by default, please ensure your strings are long
// enough when changing adapters.
// See https://www.prisma.io/docs/orm/reference/prisma-schema-reference#string for more information
datasource db {
  provider = "sqlite"
  // Use env-based URL so production can point at a persistent volume (e.g., file:/data/dev.sqlite)
  url      = env("DATABASE_URL")
}

model Session {
  id            String    @id
  shop          String
  state         String
  isOnline      Boolean   @default(false)
  scope         String?
  expires       DateTime?
  accessToken   String
  userId        BigInt?
  firstName     String?
  lastName      String?
  email         String?
  accountOwner  Boolean   @default(false)
  locale        String?
  collaborator  Boolean?  @default(false)
  emailVerified Boolean?  @default(false)
}

// SENTINEL: products-workspace-v3-0 (Prisma models)
// BEGIN products-workspace-v3-0
enum SpecFieldType {
  text
  number
  boolean
  select
}

enum FieldStorage {
  CORE
  METAFIELD
}

model SpecTemplate {
  id        String      @id @default(cuid())
  name      String      @unique
  // <!-- BEGIN RBP GENERATED: importer-templates-zero-orphan-v1 -->
  status    TemplateStatus @default(ACTIVE)
  // <!-- END RBP GENERATED: importer-templates-zero-orphan-v1 -->
  // <!-- BEGIN RBP GENERATED: importer-templates-orphans-v1 -->
  // Optional template-level cost used by importer defaults and UI. No default; managed via core cost field instead.
  cost      Float?
  // Product image URL (optional) for importer to attach a default product image
  productImageUrl String?
  // Supplier availability metadata (read-only in UI, updated by importer)
  supplierAvailability String?
  // <!-- END RBP GENERATED: importer-templates-orphans-v1 -->
  fields    SpecField[]
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  // Versioning
  versions TemplateVersion[]
  // Phase 2 (hybrid): when this row is a draft derived from a remote published template
  remoteTemplateId String?   // canonical template_id (remote handle)
  remoteVersion    Int?      // remote version at import time

  @@index([remoteTemplateId])
}

// <!-- BEGIN RBP GENERATED: importer-templates-zero-orphan-v1 -->
enum TemplateStatus {
  PENDING
  ACTIVE
  ARCHIVED
}
// <!-- END RBP GENERATED: importer-templates-zero-orphan-v1 -->

model SpecField {
  id                 String        @id @default(cuid())
  templateId         String
  template           SpecTemplate  @relation(fields: [templateId], references: [id], onDelete: Cascade)
  key                String
  label              String
  type               SpecFieldType
  required           Boolean       @default(false)
  position           Int
  storage            FieldStorage
  coreFieldPath      String?
  metafieldNamespace String?
  metafieldKey       String?
  metafieldType      String?

  @@unique([templateId, key])
}

model TemplateVersion {
  id          String       @id @default(cuid())
  templateId  String
  template    SpecTemplate  @relation(fields: [templateId], references: [id], onDelete: Cascade)
  versionNumber Int
  // Using String storage for now; upgrade to Json later with a dedicated migration.
  dataJson     String
  publishedAt  DateTime @default(now())
  createdAt    DateTime @default(now())

  @@unique([templateId, versionNumber])
}
// END products-workspace-v3-0

// Product type to template mapping
model ProductTypeTemplateMap {
  id          String   @id @default(cuid())
  productType String   @unique
  templateId  String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// <!-- BEGIN RBP GENERATED: supplier-importer-v1 -->
/// Supplier Importer models
model ImportProfile {
  id             String   @id @default(cuid())
  supplierDomain String
  productType    String
  mappingJson    Json
  paginationJson Json?
  followDetail   Boolean  @default(false)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  jobs           ImportJob[]

  @@unique([supplierDomain, productType])
}

model ImportJob {
  id          String        @id @default(cuid())
  profileId   String?
  profile     ImportProfile? @relation(fields: [profileId], references: [id])
  url         String
  productType String
  status      String        @default("queued") // queued | running | completed | failed | cancelled
  countsJson  Json          // { total, processed, created, updated, skipped, errors }
  logJson     Json          // array of log lines
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  items       ImportItem[]
}

model ImportItem {
  id         String     @id @default(cuid())
  jobId      String
  job        ImportJob  @relation(fields: [jobId], references: [id], onDelete: Cascade)
  sourceUrl  String
  rawJson    Json
  mappedJson Json?
  status     String      @default("pending") // pending | mapped | created | updated | skipped | error
  error      String?
  createdAt  DateTime    @default(now())
}
// <!-- BEGIN RBP GENERATED: supplier-inventory-sync-v1 -->
model SupplierAuthProfile {
  id             String   @id @default(cuid())
  supplierDomain String
  loginUrl       String
  username       String
  passwordEnc    String
  cookieJarJson  Json?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([supplierDomain, username])
}

model SupplierInventorySnapshot {
  id             String   @id @default(cuid())
  supplierDomain String
  productCode    String
  qtyAvailable   Int?
  cost           Float?
  lastSeenAt     DateTime?
  snapshotJson   Json?
  status         String
  createdAt      DateTime @default(now())
}
// <!-- END RBP GENERATED: supplier-inventory-sync-v1 -->
// <!-- END RBP GENERATED: supplier-importer-v1 -->

// <!-- BEGIN RBP GENERATED: importer-v2-schema -->
model ImporterVersion {
  id        Int      @id @default(1)
  version   String   @default("2.0-scrape")
  updatedAt DateTime @updatedAt
}

model ImportRun {
  id         String   @id @default(cuid())
  supplierId String
  startedAt  DateTime @default(now())
  finishedAt DateTime?
  status     String   // started success failed
  // Progress/state snapshot for UI streaming and polling
  // Shape: { phase: string, percent: number, etaSeconds?: number, counts?: Json, details?: Json }
  progress   Json?
  summary    Json?
}

model ImportDiff {
  id          String   @id @default(cuid())
  importRunId String
  externalId  String
  diffType    String   // add change delete conflict
  before      Json?
  after       Json?
  validation  Json?
  resolution  String?  // approve reject edit
  resolvedBy  String?
  resolvedAt  DateTime?
}

model PartStaging {
  id          String   @id @default(cuid())
  supplierId  String
  // Template-scoped staging to isolate multiple imports under same supplier
  templateId  String?
  externalId  String
  title       String
  partType    String
  description String?
  images      Json?
  rawSpecs    Json?
  normSpecs   Json?
  priceMsrp   Decimal?
  priceWh     Decimal?
  availability String?
  hashContent String   @default("")
  fetchedAt   DateTime @default(now())
  designStudioReady Boolean   @default(false)
  designStudioFamily String?
  designStudioSeries String?
  designStudioRole  String?
  designStudioCompatibility Json?
  designStudioCoverageNotes String?
  designStudioSourceQuality String?
  designStudioHash   String   @default("")
  designPartType String?
  designStudioBlockingReasons Json?

  // Back-writes from publish pipeline
  shopifyProductId String?
  shopifyVariantIds Json?
  publishedAt      DateTime?
  publishStatus    String?   // created | updated | skipped | error
  publishResult    Json?

  @@unique([supplierId, templateId, externalId], name: "part_staging_supplier_template_ext_unique")
}
// <!-- END RBP GENERATED: importer-v2-schema -->

// <!-- BEGIN RBP GENERATED: hq-importer-new-import-v2 (mapping-snapshot-schema) -->
/// Global template-level alias memory: maps a normalized source label to a template field key.
model TemplateAlias {
  id          String   @id @default(cuid())
  templateId  String
  // Normalized source label (e.g., "item_length_in")
  labelNorm   String
  fieldKey    String
  source      String   @default("manual") // manual | auto
  confidence  Float    @default(1.0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([templateId, labelNorm], name: "template_alias_unique")
}

/// Per-run mapping snapshot capturing applied alias choices and axes mapping
model RunMappingSnapshot {
  id         String   @id @default(cuid())
  runId      String
  templateId String
  scraperId  String
  // JSON blob: { aliases: [{ label, fieldKey, source, confidence }], axes: { o1, o2, o3 } }
  mapping    Json
  createdAt  DateTime @default(now())

  @@unique([runId])
}

/// Optional per-item applied mapping materialization for diagnostics
model RunItemMapping {
  id         String   @id @default(cuid())
  runId      String
  itemKey    String
  applied    Json     // { fieldKey: value }
  diagnostics Json    // { missing:[], sources:{} }
  createdAt  DateTime @default(now())

  @@index([runId])
  @@unique([runId, itemKey], name: "run_item_mapping_unique")
}
// <!-- END RBP GENERATED: hq-importer-new-import-v2 (mapping-snapshot-schema) -->

// <!-- BEGIN RBP GENERATED: importer-seeds-v1 -->
model ProductSource {
  id           String   @id @default(cuid())
  supplierId   String
  supplier     Supplier @relation("SupplierSources", fields: [supplierId], references: [id])
  // Template-scoped product sources (seeds) to avoid cross-template bleed
  templateId   String?
  url          String
  externalId   String?
  source       String   // 'manual' | 'discovered' | 'forced'
  notes        String?
  htmlHash     String?
  firstSeenAt  DateTime @default(now())
  lastSeenAt   DateTime @default(now())
  // Link to canonical Product when known (after first successful normalization/upsert)
  productId    String?
  product      Product? @relation("ProductSources", fields: [productId], references: [id])

  @@unique([supplierId, templateId, url], name: "product_source_supplier_template_url_unique")
}
// <!-- END RBP GENERATED: importer-seeds-v1 -->

// <!-- BEGIN RBP GENERATED: hq-import-settings-v1 -->
model SupplierCredentials {
  id          String   @id @default(cuid())
  supplierId  String
  usernameEnc String
  passwordEnc String
  totpEnc     String?
  updatedBy   String?
  updatedAt   DateTime @updatedAt

  @@unique([supplierId], name: "supplier_credentials_unique")
}

model ImportSchedule {
  id         String   @id @default(cuid())
  supplierId String
  enabled    Boolean  @default(true)
  cron       String   // e.g. "0 3 * * *"
  profile    String   // "price_avail"
  lastRunAt  DateTime?
  nextDueAt  DateTime?
}
// <!-- END RBP GENERATED: hq-import-settings-v1 -->

// <!-- BEGIN RBP GENERATED: importer-price-avail-job-v1 -->
model SupplierCookieJar {
  supplierId   String   @id
  jarEncrypted String
  lastLoginAt  DateTime
  expiresAt    DateTime?
  updatedAt    DateTime @updatedAt
}
// <!-- END RBP GENERATED: importer-price-avail-job-v1 -->

model SupplierSyncState {
  id                    String   @id @default(cuid())
  supplierSlug          String   @unique
  authCookieEnc         String?
  authCookieSetAt       DateTime?
  authCookieSetBy       String?
  authCookieValidatedAt DateTime?
  authStatus            String?
  authMessage           String?
  lastSyncJobId         String?
  lastSyncAt            DateTime?
  lastSyncStatus        String?
  lastSyncSummary       Json?
  lastSyncError         String?
  currentSyncRun        Json?
  lastSyncRun           Json?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
}

// <!-- BEGIN RBP GENERATED: importer-v2-3 -->
model ImportTemplate {
  id            String   @id
  name          String
  // importer v2.3 config/state blob (template-first 1:1)
  importConfig  Json
  // quick status for Home row
  state         String   @default("NEEDS_SETTINGS")
  lastRunAt     DateTime?
  hadFailures   Boolean  @default(false)
  // current preparing run (async review prep); cleared on completion/failure
  preparingRunId String?

  // logs relation
  logs          ImportLog[]

  @@index([state])
  @@index([preparingRunId])
}

// BEGIN product_db canonical models (phase 1)
/// Supplier: distinct source of products. Consolidates legacy supplierId uses.
model Supplier {
  id         String   @id @default(cuid())
  slug       String   @unique
  name       String
  urlRoot    String?
  active     Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  products   Product[]
  sources    ProductSource[] @relation("SupplierSources")
}

/// Product: stable identity keyed by (supplierId, sku)
model Product {
  id              String          @id @default(cuid())
  supplierId      String
  supplier        Supplier        @relation(fields: [supplierId], references: [id], onDelete: Cascade)
  sku             String
  title           String
  type            String?
  designPartType  String?
  status          ProductStatus   @default(DRAFT) // DRAFT READY PUBLISHED
  latestVersionId String?         @unique
  // Distinct relation for the latest (pointer) version to avoid ambiguity with versions history relation
  latestVersion   ProductVersion? @relation("LatestProductVersion", fields: [latestVersionId], references: [id])
  publishHandle   String?
  description     String?
  images          Json?
  priceMsrp       Decimal?
  priceWholesale  Decimal?
  availability    String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  // Full version history (many) relation name distinct from latestVersion pointer
  versions        ProductVersion[] @relation("ProductVersions")
  sources         ProductSource[]  @relation("ProductSources")
  designStudioReady Boolean        @default(false)
  designStudioFamily String?
  designStudioSeries String?
  designStudioRole   String?
  designStudioCompatibility Json?
  designStudioSourceQuality String?
  designStudioLastTouchedAt DateTime?
  designStudioCoverageNotes String?
  designStudioHash   String   @default("")
  designStudioBlockingReasons Json?
  annotationAudits DesignStudioAnnotationAudit[]

  @@unique([supplierId, sku], name: "product_supplier_sku_unique")
  @@index([supplierId])
}

enum ProductStatus {
  DRAFT
  READY
  PUBLISHED
}

enum DesignBuildStatus {
  DRAFT
  REVIEW
  APPROVED
  SCHEDULED
  IN_PROGRESS
  FULFILLED
  ARCHIVED
  BLOCKED
}

enum DesignFulfillmentMode {
  RBP_BUILD
  SUPPLIER_BUILD
}

enum DesignBuildEventType {
  NOTE
  STATUS_CHANGE
  CUSTOMER_UPDATE
  FULFILLMENT_UPDATE
  SLA_BREACH
  FILE_ATTACHED
  EXPORT
}

enum DesignStudioTier {
  STARTER
  CORE
  PLUS
  ENTERPRISE
}

enum DesignStorefrontDraftStatus {
  ACTIVE
  SUBMITTED
  EXPIRED
}

/// ProductVersion: immutable snapshot of normalized content
model ProductVersion {
  id            String   @id @default(cuid())
  productId     String
  // Belongs-to relation paired with Product.versions history.
  product       Product  @relation("ProductVersions", fields: [productId], references: [id], onDelete: Cascade)
  // Back reference for latestVersion pointer
  productsLatest Product[] @relation("LatestProductVersion")
  designPartType  String?
  contentHash   String
  rawSpecs      Json?
  normSpecs     Json?
  description   String?
  images        Json?
  priceMsrp     Decimal?
  priceWholesale Decimal?
  availability  String?
  sourceSnapshot Json?
  fetchedAt     DateTime @default(now())
  createdAt     DateTime @default(now())
  designStudioReady Boolean @default(false)
  designStudioFamily String?
  designStudioRole String?
  designStudioSeries String?
  designStudioCompatibility Json?
  designStudioSourceQuality String?
  designStudioCoverageNotes String?
  designStudioHash  String   @default("")
  designStudioBlockingReasons Json?
  annotationAudits DesignStudioAnnotationAudit[] @relation("ProductVersionAnnotationAudits")

  @@unique([productId, contentHash], name: "product_version_hash_unique")
  @@index([productId])
}

model DesignStudioAnnotationAudit {
  id                String         @id @default(cuid())
  productId         String
  product           Product        @relation(fields: [productId], references: [id], onDelete: Cascade)
  productVersionId  String?
  productVersion    ProductVersion? @relation("ProductVersionAnnotationAudits", fields: [productVersionId], references: [id], onDelete: SetNull)
  designStudioHash  String
  ready             Boolean
  family            String?
  series            String?
  role              String?
  coverageNotes     String?
  sourceQuality     String?
  compatibility     Json?
  recordedAt        DateTime       @default(now())
  source            String         @default("importer")

  @@index([productId, recordedAt])
  @@index([designStudioHash])
}
// END product_db canonical models (phase 1)

model DesignBuild {
  id               String                @id @default(cuid())
  reference        String                @unique
  shopDomain       String
  tier             DesignStudioTier      @default(STARTER)
  status           DesignBuildStatus     @default(DRAFT)
  fulfillmentMode  DesignFulfillmentMode @default(RBP_BUILD)
  storefrontDraftId String?              @unique
  storefrontDraft  DesignStorefrontDraft? @relation("DraftToBuild", fields: [storefrontDraftId], references: [id], onDelete: SetNull)
  customerName     String?
  customerEmail    String?
  customerPhone    String?
  useCase          String?
  experienceLevel  String?
  blankSku         String?
  blankTitle       String?
  componentSummary Json?
  bomHash          String?
  promisedShipWeek DateTime?
  assignedBuilder  String?
  budgetCeiling    Decimal?
  notesJson        Json?
  metadata         Json?
  submittedAt      DateTime?
  approvedAt       DateTime?
  scheduledAt      DateTime?
  fulfilledAt      DateTime?
  blockedReason    String?
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt

  events           DesignBuildEvent[]
  attachments      DesignBuildAttachment[]

  @@index([shopDomain, status])
  @@index([tier])
  @@index([storefrontDraftId])
}

model DesignStorefrontDraft {
  id           String                      @id @default(cuid())
  token        String                      @unique
  shopDomain   String
  tier         DesignStudioTier            @default(STARTER)
  status       DesignStorefrontDraftStatus @default(ACTIVE)
  selections   Json?
  summary      Json?
  customer     Json?
  metadata     Json?
  notes        String?
  expiresAt    DateTime?
  submittedAt  DateTime?
  createdAt    DateTime                    @default(now())
  updatedAt    DateTime                    @updatedAt
  builds       DesignBuild[]               @relation("DraftToBuild")

  @@index([shopDomain, status])
}

model DesignBuildEvent {
  id          String              @id @default(cuid())
  buildId     String
  build       DesignBuild         @relation(fields: [buildId], references: [id], onDelete: Cascade)
  eventType   DesignBuildEventType
  payload     Json?
  performedBy String?
  createdAt   DateTime            @default(now())

  @@index([buildId, createdAt])
}

model DesignBuildAttachment {
  id        String      @id @default(cuid())
  buildId   String
  build     DesignBuild @relation(fields: [buildId], references: [id], onDelete: Cascade)
  label     String?
  url       String
  type      String?
  metadata  Json?
  createdAt DateTime    @default(now())

  @@index([buildId])
}

model TenantSettings {
  id                  String           @id @default(cuid())
  shopDomain          String           @unique
  designStudioEnabled Boolean          @default(false)
  designStudioTier    DesignStudioTier @default(STARTER)
  designStudioConfig  Json?
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt
}

model ImportLog {
  id          String   @id @default(cuid())
  templateId  String
  runId       String
  type        String
  payload     Json
  at          DateTime @default(now())

  template    ImportTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)
  @@index([templateId, runId, type])
}
// <!-- END RBP GENERATED: importer-v2-3 -->

// BEGIN importer delete audit (v1)
/// Audit log for delete operations (dry-run previews and committed deletes).
/// Provides accountability & rollback insight. Not strictly required for runtime logic.
model ImportDeleteAudit {
  id            String   @id @default(cuid())
  templateIds   String   // comma-separated list to keep simple for SQLite (alternatively Json in future)
  countsJson    Json?    // { templates, logs, runs, diffs, staging, sources }
  deletedJson   Json?    // same shape as counts when committed
  forced        Boolean  @default(false)
  dryRun        Boolean  @default(false)
  userHq        Boolean  @default(true) // whether HQ guard passed
  blockedCodes  String?  // comma-separated blocker codes present when forced
  durationMs    Int?
  createdAt     DateTime @default(now())
}
// END importer delete audit (v1)

// BEGIN publish telemetry (canonical products)
model PublishTelemetry {
  id          String   @id @default(cuid())
  productIds  Json?
  attempted   Int      @default(0)
  created     Int      @default(0)
  updated     Int      @default(0)
  skipped     Int      @default(0)
  failed      Int      @default(0)
  startedAt   DateTime @default(now())
  finishedAt  DateTime?
  durationMs  Int?
  diag        Json?

  @@index([startedAt])
}
// END publish telemetry (canonical products)

// BEGIN import telemetry (canonical products)
model ImportTelemetry {
  id            String   @id @default(cuid())
  runId         String   @unique
  supplierId    String
  newProducts   Int      @default(0)
  newVersions   Int      @default(0)
  skipped       Int      @default(0)
  failed        Int      @default(0)
  durationMs    Int?
  startedAt     DateTime @default(now())
  finishedAt    DateTime?
  diag          Json?

  @@index([supplierId])
  @@index([startedAt])
}
// END import telemetry (canonical products)
