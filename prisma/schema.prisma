// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

// Note that some adapters may set a maximum length for the String type by default, please ensure your strings are long
// enough when changing adapters.
// See https://www.prisma.io/docs/orm/reference/prisma-schema-reference#string for more information
datasource db {
  provider = "sqlite"
  // Use env-based URL so production can point at a persistent volume (e.g., file:/data/dev.sqlite)
  url      = env("DATABASE_URL")
}

model Session {
  id            String    @id
  shop          String
  state         String
  isOnline      Boolean   @default(false)
  scope         String?
  expires       DateTime?
  accessToken   String
  userId        BigInt?
  firstName     String?
  lastName      String?
  email         String?
  accountOwner  Boolean   @default(false)
  locale        String?
  collaborator  Boolean?  @default(false)
  emailVerified Boolean?  @default(false)
}

// SENTINEL: products-workspace-v3-0 (Prisma models)
// BEGIN products-workspace-v3-0
enum SpecFieldType {
  text
  number
  boolean
  select
}

enum FieldStorage {
  CORE
  METAFIELD
}

model SpecTemplate {
  id        String      @id @default(cuid())
  name      String      @unique
  // <!-- BEGIN RBP GENERATED: importer-templates-zero-orphan-v1 -->
  status    TemplateStatus @default(ACTIVE)
  // <!-- END RBP GENERATED: importer-templates-zero-orphan-v1 -->
  // <!-- BEGIN RBP GENERATED: importer-templates-orphans-v1 -->
  // Optional template-level cost used by importer defaults and UI. No default; managed via core cost field instead.
  cost      Float?
  // Product image URL (optional) for importer to attach a default product image
  productImageUrl String?
  // Supplier availability metadata (read-only in UI, updated by importer)
  supplierAvailability String?
  // <!-- END RBP GENERATED: importer-templates-orphans-v1 -->
  fields    SpecField[]
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  // Versioning
  versions TemplateVersion[]
  // Phase 2 (hybrid): when this row is a draft derived from a remote published template
  remoteTemplateId String?   // canonical template_id (remote handle)
  remoteVersion    Int?      // remote version at import time

  @@index([remoteTemplateId])
}

// <!-- BEGIN RBP GENERATED: importer-templates-zero-orphan-v1 -->
enum TemplateStatus {
  PENDING
  ACTIVE
  ARCHIVED
}
// <!-- END RBP GENERATED: importer-templates-zero-orphan-v1 -->

model SpecField {
  id                 String        @id @default(cuid())
  templateId         String
  template           SpecTemplate  @relation(fields: [templateId], references: [id], onDelete: Cascade)
  key                String
  label              String
  type               SpecFieldType
  required           Boolean       @default(false)
  position           Int
  storage            FieldStorage
  coreFieldPath      String?
  metafieldNamespace String?
  metafieldKey       String?
  metafieldType      String?

  @@unique([templateId, key])
}

model TemplateVersion {
  id          String       @id @default(cuid())
  templateId  String
  template    SpecTemplate  @relation(fields: [templateId], references: [id], onDelete: Cascade)
  versionNumber Int
  // Using String storage for now; upgrade to Json later with a dedicated migration.
  dataJson     String
  publishedAt  DateTime @default(now())
  createdAt    DateTime @default(now())

  @@unique([templateId, versionNumber])
}
// END products-workspace-v3-0

// Product type to template mapping
model ProductTypeTemplateMap {
  id          String   @id @default(cuid())
  productType String   @unique
  templateId  String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// <!-- BEGIN RBP GENERATED: supplier-importer-v1 -->
/// Supplier Importer models
model ImportProfile {
  id             String   @id @default(cuid())
  supplierDomain String
  productType    String
  mappingJson    Json
  paginationJson Json?
  followDetail   Boolean  @default(false)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  jobs           ImportJob[]

  @@unique([supplierDomain, productType])
}

model ImportJob {
  id          String        @id @default(cuid())
  profileId   String?
  profile     ImportProfile? @relation(fields: [profileId], references: [id])
  url         String
  productType String
  status      String        @default("queued") // queued | running | completed | failed | cancelled
  countsJson  Json          // { total, processed, created, updated, skipped, errors }
  logJson     Json          // array of log lines
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  items       ImportItem[]
}

model ImportItem {
  id         String     @id @default(cuid())
  jobId      String
  job        ImportJob  @relation(fields: [jobId], references: [id], onDelete: Cascade)
  sourceUrl  String
  rawJson    Json
  mappedJson Json?
  status     String      @default("pending") // pending | mapped | created | updated | skipped | error
  error      String?
  createdAt  DateTime    @default(now())
}
// <!-- BEGIN RBP GENERATED: supplier-inventory-sync-v1 -->
model SupplierAuthProfile {
  id             String   @id @default(cuid())
  supplierDomain String
  loginUrl       String
  username       String
  passwordEnc    String
  cookieJarJson  Json?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([supplierDomain, username])
}

model SupplierInventorySnapshot {
  id             String   @id @default(cuid())
  supplierDomain String
  productCode    String
  qtyAvailable   Int?
  cost           Float?
  lastSeenAt     DateTime?
  snapshotJson   Json?
  status         String
  createdAt      DateTime @default(now())
}
// <!-- END RBP GENERATED: supplier-inventory-sync-v1 -->
// <!-- END RBP GENERATED: supplier-importer-v1 -->

// <!-- BEGIN RBP GENERATED: importer-v2-schema -->
model ImporterVersion {
  id        Int      @id @default(1)
  version   String   @default("2.0-scrape")
  updatedAt DateTime @updatedAt
}

model ImportRun {
  id         String   @id @default(cuid())
  supplierId String
  startedAt  DateTime @default(now())
  finishedAt DateTime?
  status     String   // started success failed
  // Progress/state snapshot for UI streaming and polling
  // Shape: { phase: string, percent: number, etaSeconds?: number, counts?: Json, details?: Json }
  progress   Json?
  summary    Json?
}

model ImportDiff {
  id          String   @id @default(cuid())
  importRunId String
  externalId  String
  diffType    String   // add change delete conflict
  before      Json?
  after       Json?
  validation  Json?
  resolution  String?  // approve reject edit
  resolvedBy  String?
  resolvedAt  DateTime?
}

model PartStaging {
  id          String   @id @default(cuid())
  supplierId  String
  // Template-scoped staging to isolate multiple imports under same supplier
  templateId  String?
  externalId  String
  title       String
  partType    String
  description String?
  images      Json?
  rawSpecs    Json?
  normSpecs   Json?
  priceMsrp   Decimal?
  priceWh     Decimal?
  hashContent String   @default("")
  fetchedAt   DateTime @default(now())

  // Back-writes from publish pipeline
  shopifyProductId String?
  shopifyVariantIds Json?
  publishedAt      DateTime?
  publishStatus    String?   // created | updated | skipped | error
  publishResult    Json?

  @@unique([supplierId, templateId, externalId], name: "part_staging_supplier_template_ext_unique")
}
// <!-- END RBP GENERATED: importer-v2-schema -->

// <!-- BEGIN RBP GENERATED: hq-importer-new-import-v2 (mapping-snapshot-schema) -->
/// Global template-level alias memory: maps a normalized source label to a template field key.
model TemplateAlias {
  id          String   @id @default(cuid())
  templateId  String
  // Normalized source label (e.g., "item_length_in")
  labelNorm   String
  fieldKey    String
  source      String   @default("manual") // manual | auto
  confidence  Float    @default(1.0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([templateId, labelNorm], name: "template_alias_unique")
}

/// Per-run mapping snapshot capturing applied alias choices and axes mapping
model RunMappingSnapshot {
  id         String   @id @default(cuid())
  runId      String
  templateId String
  scraperId  String
  // JSON blob: { aliases: [{ label, fieldKey, source, confidence }], axes: { o1, o2, o3 } }
  mapping    Json
  createdAt  DateTime @default(now())

  @@unique([runId])
}

/// Optional per-item applied mapping materialization for diagnostics
model RunItemMapping {
  id         String   @id @default(cuid())
  runId      String
  itemKey    String
  applied    Json     // { fieldKey: value }
  diagnostics Json    // { missing:[], sources:{} }
  createdAt  DateTime @default(now())

  @@index([runId])
  @@unique([runId, itemKey], name: "run_item_mapping_unique")
}
// <!-- END RBP GENERATED: hq-importer-new-import-v2 (mapping-snapshot-schema) -->

// <!-- BEGIN RBP GENERATED: importer-seeds-v1 -->
model ProductSource {
  id           String   @id @default(cuid())
  supplierId   String
  supplier     Supplier @relation("SupplierSources", fields: [supplierId], references: [id])
  // Template-scoped product sources (seeds) to avoid cross-template bleed
  templateId   String?
  url          String
  externalId   String?
  source       String   // 'manual' | 'discovered' | 'forced'
  notes        String?
  firstSeenAt  DateTime @default(now())
  lastSeenAt   DateTime @default(now())
  // Link to canonical Product when known (after first successful normalization/upsert)
  productId    String?
  product      Product? @relation("ProductSources", fields: [productId], references: [id])

  @@unique([supplierId, templateId, url], name: "product_source_supplier_template_url_unique")
}
// <!-- END RBP GENERATED: importer-seeds-v1 -->

// <!-- BEGIN RBP GENERATED: hq-import-settings-v1 -->
model SupplierCredentials {
  id          String   @id @default(cuid())
  supplierId  String
  usernameEnc String
  passwordEnc String
  totpEnc     String?
  updatedBy   String?
  updatedAt   DateTime @updatedAt

  @@unique([supplierId], name: "supplier_credentials_unique")
}

model ImportSchedule {
  id         String   @id @default(cuid())
  supplierId String
  enabled    Boolean  @default(true)
  cron       String   // e.g. "0 3 * * *"
  profile    String   // "price_avail"
  lastRunAt  DateTime?
  nextDueAt  DateTime?
}
// <!-- END RBP GENERATED: hq-import-settings-v1 -->

// <!-- BEGIN RBP GENERATED: importer-price-avail-job-v1 -->
model SupplierCookieJar {
  supplierId   String   @id
  jarEncrypted String
  lastLoginAt  DateTime
  expiresAt    DateTime?
  updatedAt    DateTime @updatedAt
}
// <!-- END RBP GENERATED: importer-price-avail-job-v1 -->

// <!-- BEGIN RBP GENERATED: importer-v2-3 -->
model ImportTemplate {
  id            String   @id
  name          String
  // importer v2.3 config/state blob (template-first 1:1)
  importConfig  Json
  // quick status for Home row
  state         String   @default("NEEDS_SETTINGS")
  lastRunAt     DateTime?
  hadFailures   Boolean  @default(false)
  // current preparing run (async review prep); cleared on completion/failure
  preparingRunId String?

  // logs relation
  logs          ImportLog[]

  @@index([state])
  @@index([preparingRunId])
}

// BEGIN product_db canonical models (phase 1)
/// Supplier: distinct source of products. Consolidates legacy supplierId uses.
model Supplier {
  id         String   @id @default(cuid())
  slug       String   @unique
  name       String
  urlRoot    String?
  active     Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  products   Product[]
  sources    ProductSource[] @relation("SupplierSources")
}

/// Product: stable identity keyed by (supplierId, sku)
model Product {
  id              String          @id @default(cuid())
  supplierId      String
  supplier        Supplier        @relation(fields: [supplierId], references: [id], onDelete: Cascade)
  sku             String
  title           String
  type            String?
  status          ProductStatus   @default(DRAFT) // DRAFT READY PUBLISHED
  latestVersionId String?         @unique
  // Distinct relation for the latest (pointer) version to avoid ambiguity with versions history relation
  latestVersion   ProductVersion? @relation("LatestProductVersion", fields: [latestVersionId], references: [id])
  publishHandle   String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  // Full version history (many) relation name distinct from latestVersion pointer
  versions        ProductVersion[] @relation("ProductVersions")
  sources         ProductSource[]  @relation("ProductSources")

  @@unique([supplierId, sku], name: "product_supplier_sku_unique")
  @@index([supplierId])
}

enum ProductStatus {
  DRAFT
  READY
  PUBLISHED
}

/// ProductVersion: immutable snapshot of normalized content
model ProductVersion {
  id            String   @id @default(cuid())
  productId     String
  // Belongs-to relation paired with Product.versions history.
  product       Product  @relation("ProductVersions", fields: [productId], references: [id], onDelete: Cascade)
  // Back reference for latestVersion pointer
  productsLatest Product[] @relation("LatestProductVersion")
  contentHash   String
  rawSpecs      Json?
  normSpecs     Json?
  description   String?
  images        Json?
  priceMsrp     Decimal?
  priceWholesale Decimal?
  availability  String?
  sourceSnapshot Json?
  fetchedAt     DateTime @default(now())
  createdAt     DateTime @default(now())

  @@unique([productId, contentHash], name: "product_version_hash_unique")
  @@index([productId])
}
// END product_db canonical models (phase 1)

model ImportLog {
  id          String   @id @default(cuid())
  templateId  String
  runId       String
  type        String
  payload     Json
  at          DateTime @default(now())

  template    ImportTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)
  @@index([templateId, runId, type])
}
// <!-- END RBP GENERATED: importer-v2-3 -->

// BEGIN publish telemetry (canonical products)
model PublishTelemetry {
  id          String   @id @default(cuid())
  productIds  Json?
  attempted   Int      @default(0)
  created     Int      @default(0)
  updated     Int      @default(0)
  skipped     Int      @default(0)
  failed      Int      @default(0)
  startedAt   DateTime @default(now())
  finishedAt  DateTime?
  durationMs  Int?
  diag        Json?

  @@index([startedAt])
}
// END publish telemetry (canonical products)

// BEGIN import telemetry (canonical products)
model ImportTelemetry {
  id            String   @id @default(cuid())
  runId         String   @unique
  supplierId    String
  newProducts   Int      @default(0)
  newVersions   Int      @default(0)
  skipped       Int      @default(0)
  failed        Int      @default(0)
  durationMs    Int?
  startedAt     DateTime @default(now())
  finishedAt    DateTime?
  diag          Json?

  @@index([supplierId])
  @@index([startedAt])
}
// END import telemetry (canonical products)
